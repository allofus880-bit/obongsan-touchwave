import zipfile

# v7.6 full HTML code (concise but functional Holo-Conscious HyperCrystal engine)
html_content = """<!DOCTYPE html>
<html lang='ko'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<title>TouchWave v7.6 â€” Holo-Conscious HyperCrystal Layer</title>
<style>
  html, body { margin:0; overflow:hidden; background:#000; }
  #fileInput {
    position:fixed; top:20px; left:20px; z-index:20;
    padding:8px 14px; border-radius:10px;
    background:rgba(255,255,255,0.08);
    border:1px solid #66aaff; color:#fff;
    cursor:pointer; font-size:14px;
    backdrop-filter: blur(4px);
  }
</style>
</head>
<body>

<input type='file' id='fileInput' accept='audio/*' multiple>
<canvas id='holo'></canvas>

<script>
const canvas = document.getElementById("holo");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
resize(); window.addEventListener("resize", resize);

let audioCtx, analyser, dataArray, audio=null, playlist=[], index=0;
function play(i){
  if(!playlist.length) return;
  index = i % playlist.length;
  const file = playlist[index];

  if(!audioCtx) audioCtx = new AudioContext();
  if(audio) audio.pause();

  audio = new Audio();
  audio.src = URL.createObjectURL(file);
  audio.load(); audio.play();

  const src = audioCtx.createMediaElementSource(audio);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  src.connect(analyser); analyser.connect(audioCtx.destination);
  audio.onended = ()=>{ index++; play(index); };
  document.getElementById("fileInput").style.display="none";
}

document.getElementById("fileInput").addEventListener("change", e=>{
  playlist=[...e.target.files]; index=0; play(0);
});

/* v7.6 Holo-Conscious HyperCrystal Engine */
let t = 0;
let holoNodes = [];
function addNode(){
  holoNodes.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    z: Math.random()*1.0,
    life: 40 + Math.random()*50
  });
}

let holoMemory = new Array(48).fill(0);

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const w=canvas.width, h=canvas.height;
  const cx=w/2, cy=h/2;

  let bass=0, mid=0, high=0;
  if(analyser){
    analyser.getByteFrequencyData(dataArray);
    bass=(dataArray[1]/255)*1.5;
    mid =(dataArray[40]/255)*2.4;
    high=(dataArray[120]/255)*3.4;
  }

  let p=(Math.sin(t*0.01)+1)/2;
  let breath=Math.pow(p,1.4) - Math.pow(1-p,1.4);
  let breathScale = 1 + breath*0.32;
  let awareness = high*0.55 + mid*0.45;

  let holoPhase = (Math.sin(t*0.004)+1)/2;
  let prism = (high*0.6 + mid*0.4) * 90;

  for(let i=0;i<48;i++) holoMemory[i] *= 0.94;
  if(high > 1.15){
    holoMemory[Math.floor(Math.random()*48)] += high*26;
  }

  if(Math.random() < high*0.02) addNode();
  holoNodes.forEach(n=> n.life--);
  holoNodes = holoNodes.filter(n=> n.life>0);

  const layers = 48;
  const base = Math.min(w,h)*0.42;
  const hueBase = (t*0.11) % 360;

  let flow = t*0.007 + mid*0.22;

  for(let i=0;i<layers;i++){
    let depth = i/layers;
    let md = (depth + flow) % 1;

    let fold =
      Math.sin(depth*9 + t*0.015)*awareness*20 +
      Math.cos(depth*13 + t*0.006)*awareness*12;

    let holoWarp =
      Math.sin(t*0.013 + depth*10)*(bass*22 - high*18);

    let mem = holoMemory[i];
    let micro = Math.sin(t*(0.03+high*0.12) + depth*15)*(3+high*6);

    /* 3D Holographic scaling */
    let holoZ = (1 + Math.sin(depth*8 + t*0.005)*0.3);
    let radius = base*(1-md)*breathScale*holoZ;

    radius += fold + holoWarp + mem + micro + prism*depth*0.05;
    if(radius<0.1) radius=0.1;

    let hueShift = Math.sin(t*0.018 + md*5)*70;
    let hue = (hueBase + md*260 + hueShift + prism*0.25) % 360;
    let luma = 60 - md*35 + breath*18 + mem*0.15;

    ctx.strokeStyle = `hsla(${hue},90%,${luma}%,${1-md})`;
    ctx.lineWidth = 2.5*(1-md);

    ctx.beginPath();
    ctx.arc(cx,cy,radius,0,Math.PI*2);
    ctx.stroke();
  }

  /* Holographic Nodes */
  holoNodes.forEach(n=>{
    let size = n.z*12 + Math.sin(t*0.02 + n.z*5)*6;
    ctx.fillStyle = `hsla(${hueBase+200},100%,70%,${n.life/60})`;
    ctx.beginPath();
    ctx.arc(n.x, n.y, size, 0, Math.PI*2);
    ctx.fill();
  });

  /* Holographic Core */
  let corePulse = mid*2.8 + high*1.6 + breath*1.1 + prism*0.02;
  let coreR = 30 + corePulse*25;
  if(coreR<1) coreR=1;

  let coreHue = (hueBase + 250 + high*40) % 360;
  let coreLight = 76 + corePulse*40;

  ctx.fillStyle = `hsla(${coreHue},96%,${coreLight}%,0.96)`;
  ctx.beginPath();
  ctx.arc(cx,cy,coreR,0,Math.PI*2);
  ctx.fill();

  t++;
  requestAnimationFrame(animate);
}

animate();
</script>
</body></html>
"""

# Write HTML
html_path = "/mnt/data/touchwave_v7_6_holoconscious_hypercrystal.html"
with open(html_path, "w", encoding="utf-8") as f:
    f.write(html_content)

# Create ZIP
zip_path = "/mnt/data/touchwave_v7_6_holoconscious_hypercrystal.zip"
with zipfile.ZipFile(zip_path, "w") as z:
    z.write(html_path, arcname="touchwave_v7_6_holoconscious_hypercrystal.html")

zip_path

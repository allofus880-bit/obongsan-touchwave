<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>TouchWave v5.4 — Cosmic Net Edition</title>

<style>
  html,body{
    margin:0; padding:0; overflow:hidden;
    background:#000;
    touch-action:none;
  }
  canvas{ position:absolute; top:0; left:0; }
</style>
</head>

<body>

<!-- Deep Nebula 3D -->
<canvas id="nebulaBack"></canvas>
<canvas id="nebulaMid"></canvas>
<canvas id="nebulaFront"></canvas>

<!-- Cosmic Net -->
<canvas id="cosmicNet"></canvas>

<!-- Touch fractal -->
<canvas id="touchCanvas"></canvas>

<script>
let W,H;
const cB=document.getElementById("nebulaBack");
const cM=document.getElementById("nebulaMid");
const cF=document.getElementById("nebulaFront");
const cN=document.getElementById("cosmicNet");
const cT=document.getElementById("touchCanvas");

const ctxB=cB.getContext("2d");
const ctxM=cM.getContext("2d");
const ctxF=cF.getContext("2d");
const ctxN=cN.getContext("2d");
const ctxT=cT.getContext("2d");

function resize(){
  W=cB.width=cM.width=cF.width=cN.width=cT.width=innerWidth;
  H=cB.height=cM.height=cF.height=cN.height=cT.height=innerHeight;
}
resize();
addEventListener("resize",resize);

let t=0;

// ===== 빠른 Nebula noise =====
function noise(x,y,t){
  return(
    Math.sin(x*0.002+t*0.0006)+
    Math.sin(y*0.0025+t*0.0007)+
    Math.sin((x+y)*0.0018+t*0.0004)
  )*0.33+0.5;
}

function drawNebula(ctx,shift,depth){
  const img=ctx.createImageData(W,H);
  const d=img.data;
  let i=0;
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const n=noise(x+depth*20,y+depth*30,t);
      let r=n*180+shift;
      let g=n*100+shift*0.4;
      let b=n*255;
      d[i++]=r; d[i++]=g; d[i++]=b; d[i++]=55;
    }
  }
  ctx.putImageData(img,0,0);
}

// ===== Parallax =====
let px=0,py=0;
addEventListener("mousemove",e=>{
  px=(e.clientX-W/2)*0.015;
  py=(e.clientY-H/2)*0.015;
});
addEventListener("touchmove",e=>{
  const t=e.touches[0];
  px=(t.clientX-W/2)*0.015;
  py=(t.clientY-H/2)*0.015;
});

// ===== Cosmic Net Node 생성 =====
const NODES=120;
const nodes=[];
for(let i=0;i<NODES;i++){
  nodes.push({
    x:Math.random()*W,
    y:Math.random()*H,
    vx:(Math.random()-0.5)*0.7,
    vy:(Math.random()-0.5)*0.7,
    r:1.5+Math.random()*2,
    pulse:Math.random()*Math.PI*2
  });
}

// ===== Cosmic Net 파동 =====
let shockwaves=[];
function createShock(x,y){
  shockwaves.push({x,y,r:0,alpha:1});
}

// ===== Touch fractal =====
let fractals=[];
function createFractal(x,y){
  const count=6+Math.random()*6;
  const hue=160+Math.random()*150;
  for(let i=0;i<count;i++){
    const ang=(Math.PI*2/count)*i;
    fractals.push({
      x,y,len:0,alpha:1,hue,
      speed:3+Math.random()*3,
      ang:ang+(Math.random()*0.7-0.35)
    });
  }
}

function tap(e){
  const r=cT.getBoundingClientRect();
  const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
  const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
  createShock(x,y);
  createFractal(x,y);
}
cT.addEventListener("click",tap);
cT.addEventListener("touchstart",tap);

// ===== 메인 루프 =====
function animate(){
  // Nebula
  ctxB.clearRect(0,0,W,H);
  ctxM.clearRect(0,0,W,H);
  ctxF.clearRect(0,0,W,H);

  ctxB.save(); ctxB.translate(px*0.2,py*0.2); drawNebula(ctxB,40,3); ctxB.restore();
  ctxM.save(); ctxM.translate(px*0.6,py*0.6); drawNebula(ctxM,120,2); ctxM.restore();
  ctxF.save(); ctxF.translate(px*1.0,py*1.0); drawNebula(ctxF,180,1); ctxF.restore();

  // Cosmic Net
  ctxN.clearRect(0,0,W,H);
  nodes.forEach(n=>{
    n.x+=n.vx; n.y+=n.vy;
    if(n.x<0||n.x>W) n.vx*=-1;
    if(n.y<0||n.y>H) n.vy*=-1;

    n.pulse+=0.05;
    const rad=n.r+Math.sin(n.pulse)*0.5;

    ctxN.beginPath();
    ctxN.arc(n.x,n.y,rad,0,Math.PI*2);
    ctxN.fillStyle="rgba(180,220,255,0.9)";
    ctxN.fill();
  });

  // Node 연결선
  for(let i=0;i<NODES;i++){
    for(let j=i+1;j<NODES;j++){
      const a=nodes[i], b=nodes[j];
      const dx=a.x-b.x, dy=a.y-b.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<140){
        const alpha=1-(dist/140);
        ctxN.beginPath();
        ctxN.moveTo(a.x,a.y);
        ctxN.lineTo(b.x,b.y);
        ctxN.strokeStyle=`rgba(150,200,255,${alpha*0.6})`;
        ctxN.lineWidth=1;
        ctxN.stroke();
      }
    }
  }

  // Shockwave
  shockwaves.forEach((s,i)=>{
    s.r+=6;
    s.alpha-=0.008;

    ctxN.beginPath();
    ctxN.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctxN.strokeStyle=`rgba(200,240,255,${s.alpha})`;
    ctxN.lineWidth=2;
    ctxN.stroke();

    if(s.alpha<=0) shockwaves.splice(i,1);
  });

  // Fractal
  ctxT.clearRect(0,0,W,H);
  fractals.forEach((f,i)=>{
    f.len+=f.speed;
    f.alpha-=0.01;

    const x2=f.x+Math.cos(f.ang)*f.len;
    const y2=f.y+Math.sin(f.ang)*f.len;

    ctxT.beginPath();
    ctxT.moveTo(f.x,f.y);
    ctxT.lineTo(x2,y2);
    ctxT.strokeStyle=`hsla(${f.hue+f.len*0.3},100%,70%,${f.alpha})`;
    ctxT.lineWidth=1.4;
    ctxT.stroke();

    if(f.alpha<=0) fractals.splice(i,1);
  });

  t++;
  requestAnimationFrame(animate);
}
animate();
</script>

</body>
</html>

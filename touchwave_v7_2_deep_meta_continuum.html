<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TouchWave v7.2 — Deep Meta-Continuum Layer</title>

<style>
  html, body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }
  #fileInput {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 10;
    padding: 8px 14px;
    border-radius: 10px;
    background: rgba(255,255,255,0.08);
    border: 1px solid #66aaff;
    color: #fff;
    cursor: pointer;
    font-size: 14px;
    backdrop-filter: blur(4px);
  }
</style>
</head>

<body>
<input type="file" id="fileInput" accept="audio/*" multiple>
<canvas id="meta"></canvas>

<script>
/* ============================================================
   Canvas Setup
============================================================ */
const canvas = document.getElementById("meta");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
window.addEventListener("resize", resize);

/* ============================================================
   Audio Core
============================================================ */
let audioCtx, analyser, dataArray, audio=null, playlist=[], index=0;

function play(idx){
  if(!playlist.length) return;

  index = idx % playlist.length;
  const file = playlist[index];

  if(!audioCtx) audioCtx = new AudioContext();
  if(audio) audio.pause();

  audio = new Audio();
  audio.src = URL.createObjectURL(file);
  audio.load();
  audio.play();

  const src = audioCtx.createMediaElementSource(audio);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  dataArray = new Uint8Array(analyser.frequencyBinCount);

  src.connect(analyser);
  analyser.connect(audioCtx.destination);

  audio.onended = () => { index++; play(index); };

  document.getElementById("fileInput").style.display = "none";
}

document.getElementById("fileInput").addEventListener("change", e=>{
  playlist = [...e.target.files];
  index = 0;
  play(0);
});

/* ============================================================
   TouchWave v7.2 — Deep Meta-Continuum Engine
============================================================ */

let t = 0;

/* Quantum Filaments (Bezier Curved Filament Lines) */
let filaments = [];
function addFilament(){
  filaments.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    cx: Math.random()*canvas.width,
    cy: Math.random()*canvas.height,
    dx: Math.random()*canvas.width,
    dy: Math.random()*canvas.height,
    life: 40 + Math.random()*40,
    width: 0.4 + Math.random()*1.2
  });
}

/* Meta Continuum Memory */
let metaMemory = new Array(42).fill(0);

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2;

  const layers = 42;
  const base = Math.min(w,h) * 0.42;

  const hueBase = (t*0.18) % 360;

  /* ---- Audio ---- */
  let bass=0, mid=0, high=0;
  if(analyser){
    analyser.getByteFrequencyData(dataArray);
    bass = (dataArray[1]/255)*1.4;
    mid  = (dataArray[40]/255)*1.9;
    high = (dataArray[120]/255)*2.8;
  }

  /* ---- Breath ---- */
  let breathPhase = (Math.sin(t*0.01)+1)/2;
  let inhale  = Math.pow(breathPhase, 1.5);
  let exhale  = Math.pow(1-breathPhase, 1.5);
  let breath  = inhale - exhale;
  let breathScale = 1 + breath * 0.30;

  /* ---- Awareness ---- */
  let awareness = high * 0.6 + mid * 0.5;

  /* ---- Meta Awareness Pulse ---- */
  let metaPulse = Math.sin(t*0.009 + awareness*0.3) * (awareness*30);

  /* ---- Meta Continuum Memory ---- */
  for(let i=0;i<layers;i++){
    metaMemory[i] *= 0.92;
  }
  if(high > 1.1){
    metaMemory[Math.floor(Math.random()*layers)] += high*20;
  }

  /* ---- Filament Spawn ---- */
  if(Math.random() < high*0.02){
    addFilament();
  }
  filaments.forEach(f => f.life -= 1);
  filaments = filaments.filter(f => f.life > 0);

  /* ---- Dimensional Flow ---- */
  let flowTime = t*0.009 + mid*0.25;
  let microSpeed = 0.03 + high*0.12;

  for(let i=0;i<layers;i++){
    let depth = i/layers;
    let movingDepth = (depth + flowTime) % 1;

    /* ---- Meta-Dimensional Folding ---- */
    let fold = Math.sin(t*0.006 + depth*10) * awareness*30;

    /* ---- Conscious Tensor Grid ---- */
    let tensor = (bass*25 - high*15) * Math.sin(depth*12 + t*0.02);

    /* ---- Micro Wave ---- */
    let microWave = Math.sin(t*microSpeed + depth*14) * (2 + high*4);

    /* ---- Continuum Echo ---- */
    let echo = metaMemory[i];

    /* ---- Final Radius ---- */
    let radius = base*(1-movingDepth)*breathScale;
    radius += fold + tensor + microWave + echo + metaPulse*depth;

    if(radius < 0.1) radius = 0.1;

    /* ---- Color Logic ---- */
    let hueShift = Math.sin(t*0.018 + movingDepth*3)*60;
    let hue = (hueBase + movingDepth*260 + hueShift + awareness*40) % 360;

    let luma = 58 - movingDepth*38 + breath*18 + echo*0.15;

    ctx.strokeStyle = `hsla(${hue},88%,${luma}%,${1-movingDepth})`;
    ctx.lineWidth = 3*(1-movingDepth);

    ctx.beginPath();
    ctx.arc(cx,cy,radius,0,Math.PI*2);
    ctx.stroke();
  }

  /* ============================================================
     Filament Rendering
  ============================================================ */
  filaments.forEach(f=>{
    ctx.strokeStyle = `hsla(${hueBase+200},100%,70%,${f.life/60})`;
    ctx.lineWidth = f.width;

    ctx.beginPath();
    ctx.moveTo(f.x, f.y);
    ctx.bezierCurveTo(
      f.cx, f.cy,
      f.dx, f.dy,
      f.x + Math.cos(t*0.02)*20,
      f.y + Math.sin(t*0.02)*20
    );
    ctx.stroke();
  });

  /* ============================================================
     Meta Core (more dimensional)
  ============================================================ */
  let corePulse =
    mid*2.5 + high*1.5 + breath*1.3 + metaPulse*0.25;

  let coreR = 28 + corePulse*24;
  if(coreR < 1) coreR = 1;

  let coreHue = (hueBase + 220 + high*40) % 360;
  let coreLight = 72 + corePulse*45;

  ctx.fillStyle = `hsla(${coreHue},95%,${coreLight}%,0.96)`;
  ctx.beginPath();
  ctx.arc(cx,cy,coreR,0,Math.PI*2);
  ctx.fill();

  t++;
  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>

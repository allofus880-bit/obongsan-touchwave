<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TouchWave v5.2 — Deep Nebula 3D</title>

<style>
  html,body{
    margin:0; padding:0; overflow:hidden;
    background:#000; touch-action:manipulation;
    user-select:none;
  }
  canvas{ position:absolute; top:0; left:0; }
</style>
</head>

<body>

<!-- 3중 레이어 성운 -->
<canvas id="nebulaBack"></canvas>
<canvas id="nebulaMid"></canvas>
<canvas id="nebulaFront"></canvas>

<!-- 터치 프랙탈 -->
<canvas id="touchCanvas"></canvas>

<script>
let W, H;

const cvsBack  = document.getElementById("nebulaBack");
const cvsMid   = document.getElementById("nebulaMid");
const cvsFront = document.getElementById("nebulaFront");
const cvsTouch = document.getElementById("touchCanvas");

const ctxB = cvsBack.getContext("2d");
const ctxM = cvsMid.getContext("2d");
const ctxF = cvsFront.getContext("2d");
const ctxT = cvsTouch.getContext("2d");

function resize(){
  W = cvsBack.width  = cvsMid.width  = cvsFront.width = cvsTouch.width  = innerWidth;
  H = cvsBack.height = cvsMid.height = cvsFront.height= cvsTouch.height = innerHeight;
}
resize();
addEventListener("resize", resize);

let t = 0;

// ====== 빠른 pseudo noise ======
function noise(x,y,t){
  return (
    Math.sin(x*0.002 + t*0.0006) +
    Math.sin(y*0.003 + t*0.0007) +
    Math.sin((x+y)*0.002 + t*0.0005)
  ) * 0.33 + 0.5;
}

// ========== 3중 성운 그리기 ==========
function drawNebula(ctx, colorShift, depth){
  const img = ctx.createImageData(W,H);
  const d = img.data;
  let i = 0;

  for(let y=0; y<H; y++){
    for(let x=0; x<W; x++){
      const n = noise(x+depth*20, y+depth*40, t);

      let r = n*200 + colorShift;
      let g = n*80  + colorShift*0.3;
      let b = n*255;

      d[i++] = r;
      d[i++] = g;
      d[i++] = b;
      d[i++] = 55;  // 투명 성운
    }
  }
  ctx.putImageData(img,0,0);
}

// =====★ Galaxy Dust (3단계 깊이)=====
const stars = [];
for(let i=0;i<600;i++){
  stars.push({
    x:Math.random()*innerWidth,
    y:Math.random()*innerHeight,
    z:Math.random()*3 + 1,   // 깊이(1=가까움,3=멀리)
    alpha:Math.random()
  });
}

function drawStars(ctx){
  stars.forEach(s=>{
    s.alpha += (Math.random()*0.1 - 0.05);
    if(s.alpha<0.1) s.alpha=0.1;
    if(s.alpha>1)  s.alpha=1;

    ctx.beginPath();
    ctx.arc(s.x, s.y, s.z*0.7, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
    ctx.fill();
  });
}

// ======== 손/마우스로 Parallax 구현 ========
let px=0, py=0;
addEventListener("mousemove", e=>{
  px = (e.clientX - W/2)*0.02;
  py = (e.clientY - H/2)*0.02;
});
addEventListener("touchmove", e=>{
  const touch = e.touches[0];
  px = (touch.clientX - W/2)*0.02;
  py = (touch.clientY - H/2)*0.02;
});

// 프랙탈
let fractals = [];

function createFractal(x,y){
  const count = 6 + Math.floor(Math.random()*6);
  const hue = 150 + Math.random()*150;

  for(let i=0;i<count;i++){
    const angle = (Math.PI*2/count)*i;

    fractals.push({
      x,y,
      len:0,
      alpha:1,
      hue,
      speed:2+Math.random()*2,
      ang: angle + (Math.random()*0.7 - 0.35)
    });
  }
}

function tap(e){
  const rect = cvsTouch.getBoundingClientRect();
  const x = (e.touches? e.touches[0].clientX : e.clientX)-rect.left;
  const y = (e.touches? e.touches[0].clientY : e.clientY)-rect.top;
  createFractal(x,y);
}
cvsTouch.addEventListener("click",tap);
cvsTouch.addEventListener("touchstart",tap);

// ========== 메인 루프 ==========
function animate(){
  // 깊이별 성운
  ctxB.clearRect(0,0,W,H);
  ctxM.clearRect(0,0,W,H);
  ctxF.clearRect(0,0,W,H);

  ctxB.save(); ctxB.translate(px*0.2, py*0.2); drawNebula(ctxB, 30, 3);  ctxB.restore();
  ctxM.save(); ctxM.translate(px*0.6, py*0.6); drawNebula(ctxM, 90, 2);  ctxM.restore();
  ctxF.save(); ctxF.translate(px*1.0, py*1.0); drawNebula(ctxF,150, 1);  ctxF.restore();

  // 별
  drawStars(ctxF);

  // 프랙탈
  ctxT.clearRect(0,0,W,H);
  fractals.forEach((f,i)=>{
    f.len += f.speed;
    f.alpha -= 0.009;

    const x2 = f.x + Math.cos(f.ang)*f.len;
    const y2 = f.y + Math.sin(f.ang)*f.len;

    ctxT.beginPath();
    ctxT.moveTo(f.x,f.y);
    ctxT.lineTo(x2,y2);
    ctxT.strokeStyle = `hsla(${f.hue + f.len*0.3},100%,70%,${f.alpha})`;
    ctxT.lineWidth=1.4;
    ctxT.stroke();

    if(f.alpha<=0) fractals.splice(i,1);
  });

  t++;
  requestAnimationFrame(animate);
}
animate();
</script>

</body>
</html>

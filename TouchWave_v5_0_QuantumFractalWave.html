<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TouchWave v5.0 — Quantum FractalWave (Basic)</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    touch-action: manipulation;
    user-select: none;
  }
  canvas {
    width: 100vw;
    height: 100vh;
    display: block;
  }
</style>
</head>
<body>
<canvas id="touchCanvas"></canvas>

<script>
const canvas = document.getElementById("touchCanvas");
const ctx = canvas.getContext("2d");
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let fractals = [];

function createFractal(x, y) {
  const branches = 6 + Math.floor(Math.random() * 6); // 6~12개의 가지
  const hue = 150 + Math.random() * 150;

  for (let i = 0; i < branches; i++) {
    const angle = (Math.PI * 2 / branches) * i;
    fractals.push({
      x,
      y,
      angle,
      len: 0,
      alpha: 1,
      hue,
      speed: 2 + Math.random() * 2,
      branchAngle: angle + (Math.random() * 0.7 - 0.35) // 약간의 랜덤 분기
    });
  }
}

function tap(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
  const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
  createFractal(x, y);
}
canvas.addEventListener("click", tap);
canvas.addEventListener("touchstart", tap);

function animate() {
  ctx.clearRect(0, 0, W, H);

  fractals.forEach((f, i) => {
    f.len += f.speed;
    f.alpha -= 0.008;

    const x2 = f.x + Math.cos(f.branchAngle) * f.len;
    const y2 = f.y + Math.sin(f.branchAngle) * f.len;

    ctx.beginPath();
    ctx.moveTo(f.x, f.y);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = `hsla(${f.hue + f.len * 0.2}, 100%, 70%, ${f.alpha})`;
    ctx.lineWidth = 1.4;
    ctx.stroke();

    // 작은 서브-브랜치
    if (f.len > 20 && f.len % 10 < 1) {
      const subAngle = f.branchAngle + (Math.random() * 1 - 0.5);
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(
        x2 + Math.cos(subAngle) * 12,
        y2 + Math.sin(subAngle) * 12
      );
      ctx.strokeStyle = `hsla(${f.hue + 40}, 100%, 80%, ${f.alpha * 0.7})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    if (f.alpha <= 0) fractals.splice(i, 1);
  });

  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
